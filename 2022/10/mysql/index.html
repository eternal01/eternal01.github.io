<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Mysql 索引结构 #  使用二叉树查询的时候，查询的时间复杂度是O(log n)，查询的时间效率已经很快。但是二叉树存在一个问题是，每一个分支上，最多就只有两个分支，当数据量大的时候，就会导致树的高度很高，查询的时候，IO的次数就会增多，查询的效率就会有所下降。使用B树或者B&#43;树，让一个节点，可以有多个分支，可以很好的降低树的高度，减少IO的次数，提升查询的效率。
 B树的特点是每一个节点中都会存储key和数据，而B&#43;树只有叶子节点才会存储数据信息（这里的数据信息 指 索引的数据信息。针对聚簇索引），其他的节点都只会存储key的信息。Mysql在查询的时候，因为其他节点的数据量少，可以一次性的在内存中加载更多的key的数据，以供查询使用。 B树的叶子节点之间是独立的，B&#43;树的叶子节点之间有指针将叶子节点相连接起来。Mysql是一种关系型数据库，多个数据之间可能是存在一定的关系的，当查询某一个数据的时候，可能会查询和之相关的一些其他的数据，可以很好的支持范围查询。 B树的查询效率不稳定，B&#43;树查询的效率稳定。当查询数据的时候，B树在遇到满足条件的数据之后，就会返回数据信息，不会走到叶子节点。但是B&#43;树在查询的时候，无论如何都会走到叶子节点，才会获取到数据，并返回数据信息。 因为B&#43;树的叶子节点不会存放数据信息（这里的数据信息指 完整的数据信息，包括了未添加索引的列的信息。即 索引中的 叶子节点，只会存放 索引列的数据，不包括未被索引的数据。聚簇索引包括所有数据，其他索引只包括 索引列和主键列），所以有更多的空间来存放key的信息，可以让树的高度更低，IO的次数更少，效率更高。  Mysql 索引类型，有何区别？ #    主键索引
  唯一索引
  普通索引
  组合索引
  全文索引
 聚簇索引：索引和数据处于同一个树结构中，叶子结点存储完整的数据。Innodb 使用聚簇索引 非聚簇索引：索引和数据不处于同一个树结构中，叶子结点存储的是指向数据的指针或地址信息，想获取完整数据需进行回表。MyIsam 使用非聚簇索引    Mysql 优化 #  - explain 查看sql执行计划 - explain extended 会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。 - explain partitions 相比 explain 多了个 partitions 字段。  id #  select的序列号，随select出现的顺序递增。id越大执行优先级越高；id相同则从上往下执行；id为null最后执行">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="Mysql" />
<meta property="og:description" content="Mysql 索引结构 #  使用二叉树查询的时候，查询的时间复杂度是O(log n)，查询的时间效率已经很快。但是二叉树存在一个问题是，每一个分支上，最多就只有两个分支，当数据量大的时候，就会导致树的高度很高，查询的时候，IO的次数就会增多，查询的效率就会有所下降。使用B树或者B&#43;树，让一个节点，可以有多个分支，可以很好的降低树的高度，减少IO的次数，提升查询的效率。
 B树的特点是每一个节点中都会存储key和数据，而B&#43;树只有叶子节点才会存储数据信息（这里的数据信息 指 索引的数据信息。针对聚簇索引），其他的节点都只会存储key的信息。Mysql在查询的时候，因为其他节点的数据量少，可以一次性的在内存中加载更多的key的数据，以供查询使用。 B树的叶子节点之间是独立的，B&#43;树的叶子节点之间有指针将叶子节点相连接起来。Mysql是一种关系型数据库，多个数据之间可能是存在一定的关系的，当查询某一个数据的时候，可能会查询和之相关的一些其他的数据，可以很好的支持范围查询。 B树的查询效率不稳定，B&#43;树查询的效率稳定。当查询数据的时候，B树在遇到满足条件的数据之后，就会返回数据信息，不会走到叶子节点。但是B&#43;树在查询的时候，无论如何都会走到叶子节点，才会获取到数据，并返回数据信息。 因为B&#43;树的叶子节点不会存放数据信息（这里的数据信息指 完整的数据信息，包括了未添加索引的列的信息。即 索引中的 叶子节点，只会存放 索引列的数据，不包括未被索引的数据。聚簇索引包括所有数据，其他索引只包括 索引列和主键列），所以有更多的空间来存放key的信息，可以让树的高度更低，IO的次数更少，效率更高。  Mysql 索引类型，有何区别？ #    主键索引
  唯一索引
  普通索引
  组合索引
  全文索引
 聚簇索引：索引和数据处于同一个树结构中，叶子结点存储完整的数据。Innodb 使用聚簇索引 非聚簇索引：索引和数据不处于同一个树结构中，叶子结点存储的是指向数据的指针或地址信息，想获取完整数据需进行回表。MyIsam 使用非聚簇索引    Mysql 优化 #  - explain 查看sql执行计划 - explain extended 会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。 - explain partitions 相比 explain 多了个 partitions 字段。  id #  select的序列号，随select出现的顺序递增。id越大执行优先级越高；id相同则从上往下执行；id为null最后执行" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://eternal01.github.io/2022/10/mysql/" />
<meta property="article:published_time" content="2022-10-16T10:27:37+00:00" />
<meta property="article:modified_time" content="2022-10-16T10:27:37+00:00" />
<title>Mysql | 穆小康</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.a64c3fbabd2c7a93ee90dd37db9054580fcb37b8eef93f80b6fa286b030f64af.css" integrity="sha256-pkw/ur0sepPukN0325BUWA/LN7ju&#43;T&#43;AtvooawMPZK8=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.1c3cf2cdc97945da1cf5d21d8edc5aed1ed0259accc68d16476b6f2f315c9e34.js" integrity="sha256-HDzyzcl5Rdoc9dIdjtxa7R7QJZrMxo0WR2tvLzFcnjQ=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>穆小康</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/abort-me/" class="">Resume</a>
  

        </li>
      
    
  </ul>











  
<ul>
  
  <li>
    <a href="/posts/" >
        Posts
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var menu=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Mysql</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#mysql-索引结构"><strong>Mysql 索引结构</strong></a></li>
    <li><a href="#mysql-索引类型有何区别"><strong>Mysql 索引类型，有何区别？</strong></a></li>
    <li><a href="#mysql-优化"><strong>Mysql 优化</strong></a>
      <ul>
        <li><a href="#id"><strong>id</strong></a></li>
        <li><a href="#select_type"><strong>select_type</strong></a></li>
        <li><a href="#table"><strong>table</strong></a></li>
        <li><a href="#type"><strong>type</strong></a></li>
        <li><a href="#possible_keys"><strong>possible_keys</strong></a></li>
        <li><a href="#key"><strong>key</strong></a></li>
        <li><a href="#key_len"><strong>key_len</strong></a></li>
        <li><a href="#ref"><strong>ref</strong></a></li>
        <li><a href="#rows"><strong>rows</strong></a></li>
        <li><a href="#extra"><strong>extra</strong></a></li>
        <li><a href="#filtered"><strong>filtered</strong></a></li>
        <li><a href="#partitions"><strong>partitions</strong></a></li>
      </ul>
    </li>
    <li><a href="#mysql-索引失效"><strong>Mysql 索引失效</strong></a></li>
    <li><a href="#mysql-索引下推"><strong>Mysql 索引下推</strong></a></li>
    <li><a href="#mysql-索引合并"><strong>Mysql 索引合并</strong></a></li>
    <li><a href="#mysql-高可用"><strong>Mysql 高可用</strong></a>
      <ul>
        <li><a href="#主从复制"><strong>主从复制</strong></a></li>
      </ul>
    </li>
    <li><a href="#mysql-日志的录入格式有何区别"><strong>Mysql 日志的录入格式，有何区别？</strong></a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown">
  <h1>
    <a href="/2022/10/mysql/">Mysql</a>
  </h1>
  
  <h5>October 16, 2022</h5>



  

  



<h2 id="mysql-索引结构">
  <strong>Mysql 索引结构</strong>
  <a class="anchor" href="#mysql-%e7%b4%a2%e5%bc%95%e7%bb%93%e6%9e%84">#</a>
</h2>
<p>使用二叉树查询的时候，查询的时间复杂度是O(log n)，查询的时间效率已经很快。但是二叉树存在一个问题是，每一个分支上，最多就只有两个分支，当数据量大的时候，就会导致树的高度很高，查询的时候，IO的次数就会增多，查询的效率就会有所下降。使用B树或者B+树，让一个节点，可以有多个分支，可以很好的降低树的高度，减少IO的次数，提升查询的效率。</p>
<ul>
<li>B树的特点是每一个节点中都会存储key和数据，而B+树只有叶子节点才会存储数据信息（这里的数据信息 指 索引的数据信息。针对聚簇索引），其他的节点都只会存储key的信息。Mysql在查询的时候，因为其他节点的数据量少，可以一次性的在内存中加载更多的key的数据，以供查询使用。</li>
<li>B树的叶子节点之间是独立的，B+树的叶子节点之间有指针将叶子节点相连接起来。Mysql是一种关系型数据库，多个数据之间可能是存在一定的关系的，当查询某一个数据的时候，可能会查询和之相关的一些其他的数据，可以很好的支持范围查询。</li>
<li>B树的查询效率不稳定，B+树查询的效率稳定。当查询数据的时候，B树在遇到满足条件的数据之后，就会返回数据信息，不会走到叶子节点。但是B+树在查询的时候，无论如何都会走到叶子节点，才会获取到数据，并返回数据信息。</li>
<li>因为B+树的叶子节点不会存放数据信息（这里的数据信息指 完整的数据信息，包括了未添加索引的列的信息。即 索引中的 叶子节点，只会存放 索引列的数据，不包括未被索引的数据。聚簇索引包括所有数据，其他索引只包括 索引列和主键列），所以有更多的空间来存放key的信息，可以让树的高度更低，IO的次数更少，效率更高。</li>
</ul>
<h2 id="mysql-索引类型有何区别">
  <strong>Mysql 索引类型，有何区别？</strong>
  <a class="anchor" href="#mysql-%e7%b4%a2%e5%bc%95%e7%b1%bb%e5%9e%8b%e6%9c%89%e4%bd%95%e5%8c%ba%e5%88%ab">#</a>
</h2>
<ul>
<li>
<p>主键索引</p>
</li>
<li>
<p>唯一索引</p>
</li>
<li>
<p>普通索引</p>
</li>
<li>
<p>组合索引</p>
</li>
<li>
<p>全文索引</p>
<ul>
<li>聚簇索引：索引和数据处于同一个树结构中，叶子结点存储完整的数据。Innodb 使用聚簇索引</li>
<li>非聚簇索引：索引和数据不处于同一个树结构中，叶子结点存储的是指向数据的指针或地址信息，想获取完整数据需进行回表。MyIsam 使用非聚簇索引</li>
</ul>
</li>
</ul>
<h2 id="mysql-优化">
  <strong>Mysql 优化</strong>
  <a class="anchor" href="#mysql-%e4%bc%98%e5%8c%96">#</a>
</h2>
<pre><code>- explain 查看sql执行计划
- explain extended    会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。
- explain partitions  相比 explain 多了个 partitions 字段。
</code></pre>
<h3 id="id">
  <strong>id</strong>
  <a class="anchor" href="#id">#</a>
</h3>
<p>select的序列号，随select出现的顺序递增。id越大执行优先级越高；id相同则从上往下执行；id为null最后执行</p>
<h3 id="select_type">
  <strong>select_type</strong>
  <a class="anchor" href="#select_type">#</a>
</h3>
<p>sql查询类型，简单查询or复杂查询</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">simple</td>
<td style="text-align:left">简单查询</td>
</tr>
<tr>
<td style="text-align:left">primary</td>
<td style="text-align:left">复杂查询最外层的select</td>
</tr>
<tr>
<td style="text-align:left">sbuquery</td>
<td style="text-align:left">包含在select中的子查询（不在from子句中）</td>
</tr>
<tr>
<td style="text-align:left">derived</td>
<td style="text-align:left">包含在from子句中的子查询</td>
</tr>
<tr>
<td style="text-align:left">union</td>
<td style="text-align:left">在union中第二个及以后的select</td>
</tr>
<tr>
<td style="text-align:left">union result</td>
<td style="text-align:left">从 union 临时表检索结果的 select</td>
</tr>
</tbody>
</table>
<h3 id="table">
  <strong>table</strong>
  <a class="anchor" href="#table">#</a>
</h3>
<p>sql访问的表</p>
<h3 id="type">
  <strong>type</strong>
  <a class="anchor" href="#type">#</a>
</h3>
<p>访问类型</p>
<p>效率从高到低：null &gt; system &gt; const &gt; eq_ref &gt; ref &gt; ref_or_null &gt; index_merge &gt; range &gt; index &gt; all</p>
<pre><code>常量表
1. 表中没有数据，或者只有一行数据（system类表）
2. 经where语句中的限制条件（&quot;column=常数&quot;格式的表达式）筛选后只有一行数据；这表明，在column列上存在索引，索引列可能是一个主键列，或者是唯一键的列（constant表），满足这2个条件之一的，就是常量表。
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">字段值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引</td>
</tr>
<tr>
<td style="text-align:left">system</td>
<td style="text-align:left">表内只有一条数据，const的特殊类型</td>
</tr>
<tr>
<td style="text-align:left">const</td>
<td style="text-align:left">索引一次就找到数据，const用于比较primary key或unique索引，因为只匹配一行数据，所以很快，如主键置于where列表中，MySQL就能将该查询转换为一个常量</td>
</tr>
<tr>
<td style="text-align:left">eq_ref</td>
<td style="text-align:left">唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</td>
</tr>
<tr>
<td style="text-align:left">ref</td>
<td style="text-align:left">非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，返回所有匹配某个单独值的行，然而可能会找到多个符合条件的行，属于查找和扫描的混合体</td>
</tr>
<tr>
<td style="text-align:left">ref_or_null</td>
<td style="text-align:left">类似ref，但是可以搜索值为NULL的行</td>
</tr>
<tr>
<td style="text-align:left">index_merge</td>
<td style="text-align:left">表示使用了索引合并的优化方法</td>
</tr>
<tr>
<td style="text-align:left">range</td>
<td style="text-align:left">只检索给定范围的行，使用一个索引来选择行</td>
</tr>
<tr>
<td style="text-align:left">index</td>
<td style="text-align:left">索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询</td>
</tr>
<tr>
<td style="text-align:left">all</td>
<td style="text-align:left">全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录</td>
</tr>
</tbody>
</table>
<h3 id="possible_keys">
  <strong>possible_keys</strong>
  <a class="anchor" href="#possible_keys">#</a>
</h3>
<p>可能使用的索引</p>
<h3 id="key">
  <strong>key</strong>
  <a class="anchor" href="#key">#</a>
</h3>
<p>实际使用的索引</p>
<h3 id="key_len">
  <strong>key_len</strong>
  <a class="anchor" href="#key_len">#</a>
</h3>
<p>在索引中使用的字节数</p>
<h3 id="ref">
  <strong>ref</strong>
  <a class="anchor" href="#ref">#</a>
</h3>
<p>key列记录的索引中，表查找值所用的列或常量，值为const或列名</p>
<h3 id="rows">
  <strong>rows</strong>
  <a class="anchor" href="#rows">#</a>
</h3>
<p>预估需要读取或检测的行数</p>
<h3 id="extra">
  <strong>extra</strong>
  <a class="anchor" href="#extra">#</a>
</h3>
<p>额外信息</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">using index</td>
<td style="text-align:left">查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现。一般是使用了覆盖索引(索引包含了所有查询的字段)。对于innodb来说，如果是辅助索引性能会有不少提高</td>
</tr>
<tr>
<td style="text-align:left">using where</td>
<td style="text-align:left">查询的列未被索引覆盖，where筛选条件非索引的前导列</td>
</tr>
<tr>
<td style="text-align:left">using where using index</td>
<td style="text-align:left">查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的前导列，意味着无法直接通过索引查找来查询到符合条件的数据</td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引</td>
</tr>
<tr>
<td style="text-align:left">using index condition</td>
<td style="text-align:left">与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围</td>
</tr>
<tr>
<td style="text-align:left">using temporary</td>
<td style="text-align:left">mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化</td>
</tr>
<tr>
<td style="text-align:left">using filesort</td>
<td style="text-align:left">mysql会对结果使用一个外部索引排序，而不是按索引次序从表里读取行</td>
</tr>
</tbody>
</table>
<h3 id="filtered">
  <strong>filtered</strong>
  <a class="anchor" href="#filtered">#</a>
</h3>
<p>filtered 列，是一个百分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）</p>
<h3 id="partitions">
  <strong>partitions</strong>
  <a class="anchor" href="#partitions">#</a>
</h3>
<p>如果查询是基于分区表的话，会显示查询将访问的分区。</p>
<h2 id="mysql-索引失效">
  <strong>Mysql 索引失效</strong>
  <a class="anchor" href="#mysql-%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88">#</a>
</h2>
<ul>
<li>索引列上进行操作
<ul>
<li>类型转换</li>
<li>计算</li>
</ul>
</li>
<li>like 查询以%开头</li>
<li>不满足最左前缀原则</li>
<li>or 查询</li>
<li>null列</li>
<li>!= 判断</li>
<li>查询条件发生隐式转换</li>
<li>估计全表扫描比索引快</li>
</ul>
<h2 id="mysql-索引下推">
  <strong>Mysql 索引下推</strong>
  <a class="anchor" href="#mysql-%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8">#</a>
</h2>
<p>如果查询语句中的所有的查询条件均是在索引中存在的，则Mysql服务器会把查询条件下推到存储引擎中，存储引擎判断如果满足条件就会直接返回数据，如果不满足，则继续下一条数据。</p>
<p>如果查询条件中的部分条件不是索引中的列数据信息，则存储引擎在满足索引条件之后，就会返回数据，然后Mysql服务器再去获取整个数据，然后判断数据是否满足，满足则需要，否则抛弃数据。</p>
<p>使用索引下推在一定程度上可以减少IO的次数，因为返回的数据均是满足条件的数据，Mysql服务器不用再去获取一次数据判断。</p>
<h2 id="mysql-索引合并">
  <strong>Mysql 索引合并</strong>
  <a class="anchor" href="#mysql-%e7%b4%a2%e5%bc%95%e5%90%88%e5%b9%b6">#</a>
</h2>
<p>当我们进行数据查询的时候，我们的where 语句中可能存在有多个查询条件，可能会走到多个索引。Mysql 5.1 之前只会选择其中一个索引进行数据查询，然后交给Mysql服务器去做数据过滤。5.1之后引入的索引合并（Index merge）技术，支持通过多个索引去查询数据，然后对结果进行计算。</p>
<ul>
<li>Index-Intersection</li>
<li>Index-Union</li>
<li>Index-Sort-Union</li>
</ul>
<h2 id="mysql-高可用">
  <strong>Mysql 高可用</strong>
  <a class="anchor" href="#mysql-%e9%ab%98%e5%8f%af%e7%94%a8">#</a>
</h2>
<h3 id="主从复制">
  <strong>主从复制</strong>
  <a class="anchor" href="#%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6">#</a>
</h3>
<pre><code>利用binlog实现

master节点
1. 启用二进制日志
2. 为当前节点设置全局唯一ID号
3. 重启数据库
4. 查看从二进制日志的文件和位置开始进行复制
5. 创建有复制权限的用户账号 
slave节点
1. 启用中继日志
2. 使用有复制权限的用户账号连接至主服务器，并启动复制线程
</code></pre>
<h2 id="mysql-日志的录入格式有何区别">
  <strong>Mysql 日志的录入格式，有何区别？</strong>
  <a class="anchor" href="#mysql-%e6%97%a5%e5%bf%97%e7%9a%84%e5%bd%95%e5%85%a5%e6%a0%bc%e5%bc%8f%e6%9c%89%e4%bd%95%e5%8c%ba%e5%88%ab">#</a>
</h2>
<ul>
<li>statement 每一条会修改数据的SQL都会记录在binlog中，不需要记录每一行的变化，减少了binlog的日志量，节约了IO，提高了性能，由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>row   不记录SQL语句上下文相关操作，仅保存哪条记录被修改。记录单元为每一行的改动，基本可以记录下所有变动，但由于很多操作会导致大量行的变动（如：alert table），因此这种模式的文件保存的信息太多，日志量太大，会降低性能</li>
<li>mixed 一种折衷方案，普通操作记录statement记录，当无法使用statement记录时使用row记录</li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function select(element){const selection=window.getSelection();const range=document.createRange();range.selectNodeContents(element);selection.removeAllRanges();selection.addRange(range);}
document.querySelectorAll("pre code").forEach(code=>{code.addEventListener("click",function(event){if(window.getSelection().toString()){return;}
select(code.parentElement);if(navigator.clipboard){navigator.clipboard.writeText(code.parentElement.textContent);}});});})();</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#mysql-索引结构"><strong>Mysql 索引结构</strong></a></li>
    <li><a href="#mysql-索引类型有何区别"><strong>Mysql 索引类型，有何区别？</strong></a></li>
    <li><a href="#mysql-优化"><strong>Mysql 优化</strong></a>
      <ul>
        <li><a href="#id"><strong>id</strong></a></li>
        <li><a href="#select_type"><strong>select_type</strong></a></li>
        <li><a href="#table"><strong>table</strong></a></li>
        <li><a href="#type"><strong>type</strong></a></li>
        <li><a href="#possible_keys"><strong>possible_keys</strong></a></li>
        <li><a href="#key"><strong>key</strong></a></li>
        <li><a href="#key_len"><strong>key_len</strong></a></li>
        <li><a href="#ref"><strong>ref</strong></a></li>
        <li><a href="#rows"><strong>rows</strong></a></li>
        <li><a href="#extra"><strong>extra</strong></a></li>
        <li><a href="#filtered"><strong>filtered</strong></a></li>
        <li><a href="#partitions"><strong>partitions</strong></a></li>
      </ul>
    </li>
    <li><a href="#mysql-索引失效"><strong>Mysql 索引失效</strong></a></li>
    <li><a href="#mysql-索引下推"><strong>Mysql 索引下推</strong></a></li>
    <li><a href="#mysql-索引合并"><strong>Mysql 索引合并</strong></a></li>
    <li><a href="#mysql-高可用"><strong>Mysql 高可用</strong></a>
      <ul>
        <li><a href="#主从复制"><strong>主从复制</strong></a></li>
      </ul>
    </li>
    <li><a href="#mysql-日志的录入格式有何区别"><strong>Mysql 日志的录入格式，有何区别？</strong></a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












