[{"id":0,"href":"/docs/abort-me/","title":"Resume","section":"Docs","content":"这是我的简历\n"},{"id":1,"href":"/2022/10/mysql/","title":"Mysql","section":"Posts","content":"关系型数据库和非关系型数据库（NoSQL）的区别 #  关系型数据库优点：\n 使用关系模型来组织数据，容易理解 可以保持数据的一致性 数据更新的开销较小 支持复杂查询  非关系型数据库优点：\n 无需经过SQL层的解析，读写效率高 基于键值对，读写性能高，易于拓展 可以支持多种类型数据的存储，图片、文档等 扩展（可分为内存性数据库以及文档型数据库，比如 Redis，MongoDB，HBase 等，适合场景：数据量大高可用的日志系统/地理位置存储系统）  DCL、DDL、DML #   DCL(DATA CONTROL LANGUAGE) 操作数据库用户、权限等 DDL(DATA DEFINITION LANGUAGE) 操作数据库、表结构、数据类型、表间约束等 DML(DATA MANIPULITION LANGUAGE) 操作数据库数据，增删改查等  Mysql 语句执行过程 #   客户端请求 \u0026mdash;\u0026gt; 连接器（验证用户身份，给予权限） 查询缓存（存在缓存则直接返回，不存在则继续下一步操作） 分析器（对sql进行语法分析等操作） 优化器（对执行的sql优化，选择最优的优化方案执行） 执行器（执行时会先查看用户是否拥有执行权限，调用存储引擎提供的接口） \u0026mdash;\u0026gt; 存储引擎（若开启查询缓存会缓存查询结果）  Mysql 使用索引的原因 #   提高数据查询效率  索引的三种常见数据结构和优缺点 #  三种常见的索引数据结构为哈希表、有序数组和搜索树   哈希表这种数据结构适用于等值查询，不适合范围查询。常用于NoSQL存储引擎。 有序数组只适用于静态存储引擎，等值查询和范围查询性能好，但更新数据成本高 搜索树（N叉树）由于读写性能上的优点以及适配磁盘访问模式，广泛用于关系型数据库存储引擎中  Mysql 索引结构 #  使用二叉树查询的时候，查询的时间复杂度是O(log n)，查询的时间效率已经很快。但是二叉树存在一个问题是，每一个分支上，最多就只有两个分支，当数据量大的时候，就会导致树的高度很高，查询的时候，IO的次数就会增多，查询的效率就会有所下降。使用B树或者B+树，让一个节点，可以有多个分支，可以很好的降低树的高度，减少IO的次数，提升查询的效率。\n B树的特点是每一个节点中都会存储key和数据，而B+树只有叶子节点才会存储数据信息（这里的数据信息 指 索引的数据信息。针对聚簇索引），其他的节点都只会存储key的信息。Mysql在查询的时候，因为其他节点的数据量少，可以一次性的在内存中加载更多的key的数据，以供查询使用。 B树的叶子节点之间是独立的，B+树的叶子节点之间有指针将叶子节点相连接起来。Mysql是一种关系型数据库，多个数据之间可能是存在一定的关系的，当查询某一个数据的时候，可能会查询和之相关的一些其他的数据，可以很好的支持范围查询。 B树的查询效率不稳定，B+树查询的效率稳定。当查询数据的时候，B树在遇到满足条件的数据之后，就会返回数据信息，不会走到叶子节点。但是B+树在查询的时候，无论如何都会走到叶子节点，才会获取到数据，并返回数据信息。 因为B+树的叶子节点不会存放数据信息（这里的数据信息指 完整的数据信息，包括了未添加索引的列的信息。即 索引中的 叶子节点，只会存放 索引列的数据，不包括未被索引的数据。聚簇索引包括所有数据，其他索引只包括 索引列和主键列），所以有更多的空间来存放key的信息，可以让树的高度更低，IO的次数更少，效率更高。  Mysql 索引类型，有何区别？ #    主键索引\n  唯一索引\n  普通索引\n  组合索引\n  全文索引\n 聚簇索引：索引和数据处于同一个树结构中，叶子结点存储完整的数据。Innodb 使用聚簇索引 非聚簇索引：索引和数据不处于同一个树结构中，叶子结点存储的是指向数据的指针或地址信息，想获取完整数据需进行回表。MyIsam 使用非聚簇索引    Mysql 优化 #  - explain 查看sql执行计划 - explain extended 会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。 - explain partitions 相比 explain 多了个 partitions 字段。  id #  select的序列号，随select出现的顺序递增。id越大执行优先级越高；id相同则从上往下执行；id为null为其他查询的聚合结果\nselect_type #  sql查询类型，简单查询or复杂查询\n   字段值 描述     simple 简单查询   primary 复杂查询最外层的select   subquery 包含在select中的子查询（不在from子句中）   derived 包含在from子句中的子查询   union 在union中第二个及以后的select   union result 从 union 临时表检索结果的 select   dependent union 顾名思义，第二个及之后的 union select   dependent subquery 顾名思义，第二个及之后的子查询的select    table #  sql访问的表\ntype #  访问类型\n效率从高到低：null \u0026gt; system \u0026gt; const \u0026gt; eq_ref \u0026gt; ref \u0026gt; ref_or_null \u0026gt; index_merge \u0026gt; range \u0026gt; index \u0026gt; all\n常量表 1. 表中没有数据，或者只有一行数据（system类表） 2. 经where语句中的限制条件（\u0026quot;column=常数\u0026quot;格式的表达式）筛选后只有一行数据；这表明，在column列上存在索引，索引列可能是一个主键列，或者是唯一键的列（constant表），满足这2个条件之一的，就是常量表。     字段值 描述     null mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引   system 表内只有一条数据，const的特殊类型   const 索引一次就找到数据，const用于比较primary key或unique索引，因为只匹配一行数据，所以很快，如主键置于where列表中，MySQL就能将该查询转换为一个常量   eq_ref 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描   ref 非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，返回所有匹配某个单独值的行，然而可能会找到多个符合条件的行，属于查找和扫描的混合体   ref_or_null 类似ref，但是可以搜索值为NULL的行   index_merge 表示使用了索引合并的优化方法   range 只检索给定范围的行，使用一个索引来选择行   index 索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询   all 全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录    possible_keys #  可能使用的索引\nkey #  实际使用的索引\nkey_len #  在索引中使用的字节数\nref #  key列记录的索引中，表查找值所用的列或常量，值为const或列名\nrows #  预估需要读取或检测的行数\nextra #  额外信息\n   字段值 描述     using index 查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现。一般是使用了覆盖索引(索引包含了所有查询的字段)。对于innodb来说，如果是辅助索引性能会有不少提高   using where 查询的列未被索引覆盖，where筛选条件非索引的前导列   using where using index 查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的前导列，意味着无法直接通过索引查找来查询到符合条件的数据   null 查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引   using index condition 与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围   using temporary mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化   using filesort mysql会对结果使用一个外部索引排序，而不是按索引次序从表里读取行    filtered #  filtered 列，是一个百分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）\npartitions #  如果查询是基于分区表的话，会显示查询将访问的分区。\nMysql 索引失效 #    索引列上进行操作\n 类型转换 计算    like 查询以%开头\n  不满足最左前缀原则\n  or 查询列中存在非索引列\n  != 判断\n  查询条件发生隐式转换\n  估计全表扫描比索引快\nnull列会降低查询效率\n  Mysql 索引下推 #  如果查询语句中的所有的查询条件均是在索引中存在的，则Mysql服务器会把查询条件下推到存储引擎中，存储引擎判断如果满足条件就会直接返回数据，如果不满足，则继续下一条数据。\n如果查询条件中的部分条件不是索引中的列数据信息，则存储引擎在满足索引条件之后，就会返回数据，然后Mysql服务器再去获取整个数据，然后判断数据是否满足，满足则需要，否则抛弃数据。\n使用索引下推在一定程度上可以减少IO的次数，因为返回的数据均是满足条件的数据，Mysql服务器不用再去获取一次数据判断。\nMysql 索引合并 #  当我们进行数据查询的时候，我们的where 语句中可能存在有多个查询条件，可能会走到多个索引。Mysql 5.1 之前只会选择其中一个索引进行数据查询，然后交给Mysql服务器去做数据过滤。5.1之后引入的索引合并（Index merge）技术，支持通过多个索引去查询数据，然后对结果进行计算。\n Index-Intersection Index-Union Index-Sort-Union  Mysql change buffer #  当需要更新一个数据页时，如果数据页在内存中则直接更新；而如果这个数据页不在内存中，在不影响数据一致性的前提下，Innodb会将这些更新操作缓存在change buffer中 在下次读取该数据页时，将数据页读入内存，再执行change buffer中与这个页相关的操作。通过这种方式保证数据逻辑的正确性 唯一索引的更新不能使用change buffer,只有普通索引可以使用该特性 对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统  Mysql 高可用 #  主从复制 #  利用binlog实现 master节点 1. 启用二进制日志 2. 为当前节点设置全局唯一ID号 3. 重启数据库 4. 查看从二进制日志的文件和位置开始进行复制 5. 创建有复制权限的用户账号 slave节点 1. 启用中继日志 2. 使用有复制权限的用户账号连接至主服务器，并启动复制线程  Mysql 两阶段提交 #  执行器想要更新记录R \u0026mdash;\u0026gt; Innodb将记录R加载进Buffer Pool \u0026mdash;\u0026gt; 将记录R旧值写入undo log便于回滚 \u0026mdash;\u0026gt; 执行器更新内存中的数据（此时该数据页为脏页） \u0026mdash;\u0026gt; 执行器写redo log（prepare） \u0026mdash;\u0026gt; 执行器写binlog \u0026mdash;\u0026gt; 执行器写redo log（commit）\n在恢复数据时，redolog 状态为 commit 则说明 binlog 也成功，直接恢复数据；如果 redolog 是 prepare，则需要查询对应的 binlog事务是否成功，决定是回滚还是执行。  Mysql 日志的录入格式，有何区别？ #   statement 每一条会修改数据的SQL都会记录在binlog中，不需要记录每一行的变化，减少了binlog的日志量，节约了IO，提高了性能，由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。 row 不记录SQL语句上下文相关操作，仅保存哪条记录被修改。记录单元为每一行的改动，基本可以记录下所有变动，但由于很多操作会导致大量行的变动（如：alert table），因此这种模式的文件保存的信息太多，日志量太大，会降低性能 mixed 一种折衷方案，普通操作记录statement记录，当无法使用statement记录时使用row记录  Mysql 事务特性 #  ACID，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）   原子性 事务中包含的操作要么全部成功，要么全部失败会滚 一致性 事务执行前后必须处于一致性状态 隔离性 多个并发事务之间要相互隔离，不相互影响 持久性 事务执行完成对数据库的更改是永久的  Mysql 隔离级别 #   读未提交 （脏读、不可重复读、幻读） 读已提交 （不可重复读、幻读） 可重复读 （幻读） 串行化  "},{"id":2,"href":"/2022/10/linux/","title":"Linux","section":"Posts","content":"shell 选择 #  查看当前系统使用默认shell\necho $SHELL 列出所有可用shell\ncat /etc/shells 切换shell为zsh\nchsh -s /bin/zsh 安装oh my zsh\nsh -c \u0026#34;$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)\u0026#34; 国内镜像安装\nsh -c \u0026#34;$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)\u0026#34; 卸载oh my zsh\nuninstall_oh_my_zsh 配置oh my zsh插件\nvim ~/.zshrc 修改plugins=(git z extract) z 提供智能跳转，cd加强版 extract 解压缩插件，提供x别名，x解压文件 z,extract为自带插件，直接开启即可，不需要另行安装 "},{"id":3,"href":"/2022/10/git/","title":"Git","section":"Posts","content":"Git配置 #  git config --global user.name \u0026#34;\u0026#34; git config --global user.email \u0026#34;\u0026#34; #全局配置用户名和邮箱，--global 全局 Git常用命令 #  初始化仓库\ngit init 添加本地修改至暂存区\ngit add . #添加所有修改 git add -A #添加所有修改 git add filename #添加具体文件 提交本地修改\ngit commit -m \u0026#34;描述\u0026#34; 拉取远程文件\ngit pull originname originbranchname "},{"id":4,"href":"/2022/10/homebrew/","title":"Homebrew","section":"Posts","content":"Homebrew核心概念 #     词汇 含义     formula(e) 安装包的描述文件，formulae 为复数   cellar 安装好后所在的目录   keg 具体某个包所在的目录，keg 是 cellar 的子目录   bottle 预先编译好的包，不需要现场下载编译源码，速度会快很多；官方库中的包大多都是通过 bottle 方式安装   tap 下载源，可以类比于 Linux 下的包管理器 repository   cask 安装 macOS native 应用的扩展，你也可以理解为有图形化界面的应用   bundle 描述 Homebrew 依赖的扩展    Homebrew安装 #  使用终端执行命令\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 若以上安装失败，并提醒： Failed to connect to http://raw.githubusercontent.com port 443: Connection refused. 则可以尝试使用国内源进行安装，详情请看 Gitee / CunKai / HomebrewCN。（或者科学上网）  查看安装是否成功\nbrew --version Homebrew切换源 #  Homebrew #  切换中科大源\nexport HOMEBREW_BREW_GIT_REMOTE=\u0026#34;https://mirrors.ustc.edu.cn/brew.git\u0026#34; brew update 若用户设置了环境变量 HOMEBREW_BREW_GIT_REMOTE，则每次运行 brew update 时将会自动设置远程。 推荐用户将环境变量 HOMEBREW_BREW_GIT_REMOTE 加入 shell 的 profile 设置中。  # 对于 bash 用户 echo \u0026#39;export HOMEBREW_BREW_GIT_REMOTE=\u0026#34;https://mirrors.ustc.edu.cn/brew.git\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile # 对于 zsh 用户 echo \u0026#39;export HOMEBREW_BREW_GIT_REMOTE=\u0026#34;https://mirrors.ustc.edu.cn/brew.git\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc 重置为官方地址\nunset HOMEBREW_BREW_GIT_REMOTE git -C \u0026#34;$(brew --repo)\u0026#34; remote set-url origin https://github.com/Homebrew/brew 重置回默认远程后，用户应该删除 shell 的 profile 设置中的环境变量 HOMEBREW_BREW_GIT_REMOTE 以免运行 brew update 时远程再次被更换。 若之前使用的 git config url.\u0026lt;URL\u0026gt;.insteadOf URL 的方式设置的镜像，请手动删除 config 文件（一般为 ~/.gitconfig 或仓库目录下的 .git/config）中的对应字段。  使用中科大源安装Homebrew 首先在命令行运行如下几条命令设置环境变量：\nexport HOMEBREW_BREW_GIT_REMOTE=\u0026#34;https://mirrors.ustc.edu.cn/brew.git\u0026#34; export HOMEBREW_CORE_GIT_REMOTE=\u0026#34;https://mirrors.ustc.edu.cn/homebrew-core.git\u0026#34; export HOMEBREW_BOTTLE_DOMAIN=\u0026#34;https://mirrors.ustc.edu.cn/homebrew-bottles\u0026#34; 之后在命令行运行 Homebrew 安装脚本：\n/bin/bash -c \u0026#34;$(curl -fsSL https://github.com/Homebrew/install/raw/HEAD/install.sh)\u0026#34; Homebrew-core #  替换中科大源\nexport HOMEBREW_CORE_GIT_REMOTE=\u0026#34;https://mirrors.ustc.edu.cn/homebrew-core.git\u0026#34; brew update 若用户设置了环境变量 HOMEBREW_CORE_GIT_REMOTE，则每次运行 brew update 时将会自动设置远程。 推荐用户将环境变量 HOMEBREW_CORE_GIT_REMOTE 加入 shell 的 profile 设置中。  # 对于 bash 用户 echo \u0026#39;export HOMEBREW_CORE_GIT_REMOTE=\u0026#34;https://mirrors.ustc.edu.cn/homebrew-core.git\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile # 对于 zsh 用户 echo \u0026#39;export HOMEBREW_CORE_GIT_REMOTE=\u0026#34;https://mirrors.ustc.edu.cn/homebrew-core.git\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc 重置为官方地址：\nunset HOMEBREW_CORE_GIT_REMOTE brew tap --custom-remote homebrew/core https://github.com/Homebrew/homebrew-core 重置回默认远程后，用户应该删除 shell 的 profile 设置中的环境变量 HOMEBREW_CORE_GIT_REMOTE 以免运行 brew update 时远程再次被更换。  Homebrew-bottles #  替换为中科大源\nexport HOMEBREW_BOTTLE_DOMAIN=\u0026#34;https://mirrors.ustc.edu.cn/homebrew-bottles\u0026#34; # 对于 bash 用户 echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=\u0026#34;https://mirrors.ustc.edu.cn/homebrew-bottles\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile # 对于 zsh 用户 echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=\u0026#34;https://mirrors.ustc.edu.cn/homebrew-bottles\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc Homebrew-cask #  替换为中科大源\nbrew tap --custom-remote --force-auto-update homebrew/cask https://mirrors.ustc.edu.cn/homebrew-cask.git 重置为官方地址\nbrew tap --custom-remote --force-auto-update homebrew/cask https://github.com/Homebrew/homebrew-cask Homebrew-cask-version #  替换为中科大源\nbrew tap --custom-remote --force-auto-update homebrew/cask-versions https://mirrors.ustc.edu.cn/homebrew-cask-versions.git 重置为官方地址\nbrew tap --custom-remote --force-auto-update homebrew/cask-versions https://github.com/Homebrew/homebrew-cask-versions Homebrew常用命令 #  查找\nbrew search \u0026lt;package\u0026gt; 安装\nbrew install \u0026lt;package\u0026gt; brew install \u0026lt;package\u0026gt; -v #显示详细安装信息 包信息\nbrew info brew info \u0026lt;package\u0026gt; 卸载\nbrew uninstall \u0026lt;package\u0026gt; brew uninstall --force \u0026lt;package\u0026gt; #强制卸载包 重装\nbrew reinstall \u0026lt;package\u0026gt; 列表\nbrew list --version #安装的所有包 brew list --formulae #安装的formule包 brew list --cask #安装的cask包 更新\nbrew update brew update \u0026lt;package\u0026gt; 可更新包列表\nbrew outdated 升级\nbrew upgrade brew upgrade \u0026lt;package\u0026gt; 清理旧版本\nbrew cleanup brew cleanup \u0026lt;package\u0026gt; 锁定包版本\nbrew pin \u0026lt;package\u0026gt; 取消锁定包版本\nbrew unpin \u0026lt;package\u0026gt; 查看已安装的包依赖\nbrew deps --installed --tree Homebrew安装本地包 #   执行以下命令获取包名（哈希值）  brew install \u0026lt;package\u0026gt; -v 通过其他方式下载安装包至本地 执行以下命令，获取brew安装目录  brew --cask 将下载文件迁移至brew下载目录并重命名 再次执行以下命令，因brew从本地找到文件，遂不再下载，直接执行安装  brew install \u0026lt;package\u0026gt; -v "},{"id":5,"href":"/2022/10/golang/","title":"Golang","section":"Posts","content":"Golang 数据类型 #   值类型：string,int,float,bool,array,struct，初始化后内存分配在栈中 引用类型：map,slice,channel，初始化后内存分配在堆中  Golang 中 make 和 new 的区别 #   同为给变量分配内存 make与new对堆栈分配处理是相同的，编译器优先进行逃逸分析，逃逸的才分配到堆上，否则分配于栈中 new 可为所有类型分配内存，并将内存置为零，返回分配类型的指针 make 仅为channel,slice,map分配内存，并进行初始化，返回类型  Golang 中 slice 和 array 的区别 #   均为存储相同类型的一组数据 均可通过下标获取，len获取长度，cap获取容量 数组固定长度，访问和复制超过数组长度会越界，切片容量长度可变 数组是值类型，切片是引用类型，底层指向一个数组，修改切片实际修改的为底层数组，切片扩容后底层数组会改变，内存地址随之改变  for range 时地址会发生变化么 #  for k,v range slice 中，k,v在内存中只会存在一份，每次循环对k,v进行赋值操作，k,v内存地址始终不变，所以如果需要在循环中开启协程，应使用临时变量  defer 什么时候会修改返回值 #   defer执行顺序为LIFO，即先入后出。 defer一般用来做收尾工作，释放资源，紧跟在打开资源后，防止出现内存泄露 defer在操作函数返回有名返回值或者指针时会修改返回值  Golang 中解析 tag 是如何实现的 #  利用反射机制，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力或动态知道给定数据对象的类型和结构，并有机会修改它。反射将接口变量转换成反射对象 Type 和 Value；反射可以通过反射对象 Value 还原成原先的接口变量；反射可以用来修改一个变量的值，前提是这个值可以被修改；注意：反射会一定程度上影响性能 "},{"id":6,"href":"/2022/10/redis/","title":"Redis","section":"Posts","content":"什么是Redis？Redis主要用途是什么？ #  Redis，英文全称是Remote Dictionary Server（远程字典服务），是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\nRedis数据类型 #    String(字符串)\n  Hash(哈希)\n  List(列表)\n  Set(集合)\n  Zset(有序集合)\n  Geospatial(地理位置)\n  Hyperloglog(基数统计)\n  Bitmap(位图)\n  Streams(流)\n常用命令 #  查找所有符合模式pattern的key。pattern可以使用通配符\nkeys pattern 判断key是否存在于数据库中\nexists key exists key key1 key2 ... #判断key是否存在，返回存在的个数 移动指定的key到指定的数据库实例（Redis默认有16个库），用户默认使用第0个库\nmove key index 查看key的剩余生存时间\nttl key 设置key的最大生存时间\nexpire key seconds 查看指定key的数据类型\ntype key 重命名指定key\nrename key 删除指定key和value\ndel key del key key1 key2 ... 增加指定值\nincrby key num 减去指定值\ndecrby key num 各数据类型应用场景 #    String\nredis最基本的数据类型，二进制安全的字符串，key和字符串类型的value最大为512M，但是一般key不超过1K，节约空间，也利于检索\n 缓存，热点数据 分布式session 分布式锁 incr计数器 全局ID（int类型，incrby,利用其原子性） incr限流（以访问者ip或其他信息为key,访问增加次数，超过一定次数返回false） setbit位操作  常用命令 #  添加数据\nset key value #如果key已存在，之前的value将会被覆盖 获取指定key的值\nget key 追加字符串\nappend key value #返回字符串长度；如果key不存在，则存储为新的key 获取字符串长度\nstrlen key 将value数值加一\nincr key #返回计算后的值；如果该值不是数值，将报错；如果key不存在，则自动存储新的key，并初始化为0，然后加一； 将value数值减一\ndecr key 将value数值加具体值\nincrby key increment 将value数值减具体值\ndecrby key increment 闭区间截取字符串中的一段\ngetrange key startIndex endIndex 替换从指定下标开始的字符串\nsetrange key offset value 添加数据并设置生命周期\nsetex key seconds value 添加key值不存在的数据\nsetnx key value #key值不存在时添加，返回结果1；key值已存在不添加，返回结果0； 批量添加数据\nmset key1 value1 key2 value2 key3 value3 ... 批量获取数据\nmget key1 key2 key3 ... 批量添加key值不存在的数据\nmsetnx key1 value1 key2 value2 ... #所有key都不存在设置成功，只要有一个存在设置失败   Hash\nkey-value键值对形势的集合\n 值为序列化对象时  常用命令 #  将一个或多个键值对存储到指定集合中\nhset key filed value ... 获取hash表中指定的filed值\nhget key filed 批量获取hash表中指定的filed值\nhmget key filed1 filed2 ... 获取指定hash表中的所有filed和value\nhgetall key 删除指定hash表中的一个或者多个filed\nhdel key filed1 filed2 ... 获取指定hash表中所有的filed的个数\nhlen key 判断指定hash表中指定的filed是否存在\nhexists key filed 获取指定hash表中所有filed的列表\nhkeys key 获取指定hash表中所有value的值\nhvals key   List\n保持顺序的字符串列表\n 消息队列 秒杀  常用命令 #  将一个或多个值依次插入列表的表头\nlpush key value1 value2 ... 获取列表中指定下标区间的元素\nlrange key startIndex endIndex 将一个或多个值依次插入列表的表尾\nrpush key value1 value2 ... 删除指定列表的表头元素并返回\nlpop key 删除指定列表的表尾元素并返回\nrpop key 获取指定列表中指定下标的元素并返回\nlindex key index 获取指定列表的长度\nllen key 根据count的值移除列表中的指定的某一些元素\nlrem key count value #count\u0026gt;0:从表头开始数前n个；count\u0026lt;0:从表尾开始数前n个；count=0：移除所有跟value相同的元素   Set\n无序的字符串集合，无重复项\n 无重复项列表  Redis 提供 sinterstore、sunionstore、sdiffstore 命令来将集合的交集、并集、差集的结果保存， Redis 在进行上述比较时，会比较耗费时间，所以为了提高性能可以将交集、并集、差集的结果提前保存起来，这样在需要使用时，可以直接通过 smembers 命令获取\n常用命令 #  将一个或多个元素添加到指定的集合中\nsadd key member1 member2 ... 获取指定集合中的所有元素\nsmembers key 判断指定元素在指定集合中是否存在\nsismember key member #存在返回1，不存在返回0 获取指定集合的长度\nscard key 移除指定集合中一个或者多个元素\nsrem key member1 member2 ... #不存的元素会忽略 随机获取指定集合中的n个元素\nsrandmember key [count] #count不指定，默认为1；count\u0026gt;0：随机获取的数不重复，count\u0026lt;0：随机获取的数可能重复 从指定集合中随机移除一个或者多个元素\nspop key [count] #count不指定，默认为1 从指定集合中移动指定一个元素到另一个集合中\nsmove source destination member 返回差集\nsdiff key1 key2 ... 返回交集\nsinter key1 key2 ... 返回并集\nsunion key1 key2 ...   Zset\n已排序的字符串集合\n 排行榜  常用命令 将一个或者多个member及score加入有序集合\nzadd key score1 member1 score2 member2 ... 根据指定集合获取指定区间的元素\nzrange key startindex endindex 根据指定分数区间获取元素\nzrangebyscore key min max 删除指定集合中一个或多个指定元素\nzrem key member1 member2 ... 获取集合中元素的个数\nzcard key 获取指定元素的排名\nzrank key member #正序 zrevrank key member #倒序 获取指定集合中在指定分数区间的元素个数\nzcount key min max 获取指定集合中的指定元素的分数\nzscore key member   Geospatial\n地理位置信息存储类型\n常用命令\n  Hyperloglog\n基于概率的数据类型\n常用命令\n  Bitmap\n更细化的操作，以Bit为单位\n常用命令\n  streams\n常用命令\n    Redis持久化策略 #  Redis提供持久化策略，用一些适当的手段在适当的时机将数据存在磁盘中，每次启动Redis都会自动加载磁盘的数据到内存中\n  RDB(redis默认持久化策略)\n在指定时间间隔内，redis服务执行指定次数的写操作，会自动触发依次持久化操作。\n 配置属性： save \u0026lt;seconds\u0026gt;\u0026lt;changes\u0026gt;：配置持久化策略 dbfilename：配置redis RDB持久化数据存储的文件 dir：配置redis RDB持久化文件所在目录    AOF\n采用操作日志来记录进行每一次写操作，每次redis服务启动时，都会重新执行一遍操作日志中的命令。效率较低，redis默认不开启。\n 配置属性： appendonly：配置是否开启AOF appendfilename：配置操作日志文件    Redis淘汰策略 #   noeviction 内存超过配置大小直接返回错误，不进行淘汰 allkeys-lru 内存超限时，使用lru算法淘汰最近最少使用的键 volatile-lru 内存超限时，使用lru算法淘汰设置了过期时间并且最近最少使用的键 allkeys-random 内存超限时，随机淘汰键 volatile-random 内存超限时，随机淘汰设置了过期时间的键 volatile-ttl 淘汰快到过期时间的键 volatile-lfu 淘汰设置了过期时间并且使用频率最低的键 allkeys-lfu 淘汰使用频率最低的键  "}]